# Урок 6. ООП Дизайн и Solid

## Домашняя работа №6 (HW_6)

1. Взять реализованный код в рамках семинара 4 и продемонстрировать применение принципов, усвоенных на семинаре.

2. Нужно в проекте прокомментировать участки кода, которые рефакторим, какой принцип применяем и почему.

Формат сдачи:    
Ссылка на гитхаб проект   


### Пояснение:
1. Для решения поставленной задачи были созданы следующие класса:  **TeacherService**, **TeacherView**, **TeacherController** и **Teacher**.

2. Класс **TeacherService** - отвечает только за логику работы со списком учителей. В нем храниться список учителей, добавляются новые учителя, редактируется информация о конкретном учителе и отображается список всех учителей.   

3. Класс **TeacherView** содержит методы для отображения информации о учителях. Создали метод *printTeachers*, который выводит список всех учителей на экран.   

4. Класс **TeacherController** взаимодействует с классами **TeacherService** и **TeacherView**. Он предоставляет методы для создания учителя, редактирования информации о конкретном учителе и отображения списка учителей.    

5. Создали объект класса **TeacherController** и использовать его методы для работы с учителями.    

**Для проверки соответствия Java класса принципам SOLID можно использовать следующий алгоритм действий:**

1. Принцип единственной ответственности (Single Responsibility Principle, SRP):
   - Определите, какие задачи и ответственности несет класс.
   - Проверьте, что класс отвечает только за одну задачу или аспект функциональности.
   - Если класс выполняет несколько различных задач, разделите его на отдельные классы, каждый из которых отвечает только за одну задачу.

2. Принцип открытости/закрытости (Open/Closed Principle, OCP):
   - Определите, насколько класс открыт для расширения новыми функциями.
   - Проверьте, что класс можно расширить без изменения его исходного кода.
   - Если класс не соответствует этому принципу, примените паттерны проектирования, такие как стратегия или адаптер, чтобы обеспечить его расширяемость.

3. Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP):
   - Убедитесь, что классы, производные от базового класса, могут быть использованы вместо него без нарушения корректности программы.
   - Проверьте, что классы-наследники не изменяют поведение базового класса, а только расширяют или переопределяют его функциональность.

4. Принцип разделения интерфейса (Interface Segregation Principle, ISP):
   - Убедитесь, что интерфейсы, реализуемые классом, являются независимыми и содержат только необходимые методы.
   - Проверьте, что класс не зависит от методов, которые он не использует.
   - Если класс реализует "толстый" интерфейс, разделите его на несколько более узких интерфейсов.

5. Принцип инверсии зависимостей (Dependency Inversion Principle, DIP):
   - Проверьте, что класс зависит от абстракций, а не от конкретных реализаций.
   - Убедитесь, что класс не создает экземпляры зависимых объектов напрямую, а получает их через внедрение зависимости (dependency injection).
   - Используйте интерфейсы или абстрактные классы для определения зависимостей класса.

Применение этих принципов поможет создать гибкие, расширяемые и поддерживаемые классы в вашем Java-приложении.

### Проверим по алгоритму класс **Teacher**:
1. SRP:
Класс **Teacher** имеет только одну задачу: хранит минимальные атрибуты учителя - Имя, возраст и предмет преподавания. 
Т.к. данный класс отвечает только за хранение этих данных, то можно считать, что он соответствует приципу единственной ответственности.

2. OCP:
Класс **Teacher** может раширяться без изменения его исходного кода, то можно считать, что он соответствует приципу открытости/закрытости.

3. ISP:
Класс **Teacher** содержат только необходимые методы, которые используются для реализации хранения актуальной информации о преподавателе, можно считать, что он соответствует приципу разделения интерфейса.

Таким образом, класс **Teacher** соответствует принципам SOLID.


